Зачем сортировка?
Бинарный поиск - пополам и ещё пополам, чтобы провернуть такое нужно чтобы уже массив был отсортирован.

Пузырёк: пузырёк всплывает
Долгая, просто сравниваем подряд 2 числа, основной процесс - перестановка, сравнить - быстрая операция. // погуглить и дописать

Шейкерная - как пузырьковая, но лучше. Шейкер в баре взбалтываем.
сначала сравниваем друг с другом как в пузырьке. // погуглить и дописать

Расчёска - есть шаг, каждый раз уменьшаем на коэфф (1.24733 - кто-то подобрал тестами)
Сравниваем 1 и последний,  *** // погуглить и дописать

Выборы - сложность ооочень плохая.
Ищем минимальное по всему массиву, сначала мин = первый в массиве. Потом меняем местами первое и минимальное. Потом следующий принимаем за минимальное и ищем, минуя первый эл-т (по оставшемуся куску).

Вставки:
// погуглить и дописать

Шелла:
сильно похоже на расчёску.

Быстрая:
рекурсивная // погуглить и дописать

Слиянием:
рекурсивная
// погуглить и дописать
___
Деревья (2 ЛР и 4 сем)
*картинка дерева*
нижние эл-ты - листья, остальное корни.
Высота дерева - количество уровней.
числа - родители
индексы - нужно писать в кружочек
n - кол-во эл-тов = 5
-1 - корень, потому что по условию
4 -1 4 1 1 - родители
0 1 2 3 4 - зашитые числа
В идеале делать проверки, чтобы в конце дерево не получилось разделённым.
Обычно используется в бинарном поиске.
Правый эл-т всегда больше родителя.
Левый - меньше.
Эл-т больше родителя? В правую ветвь. Всё ещё больше - правее. Опа, меньше! Влево. и т.д.
___
3 ЛР - обработка сетевых пакетов.
Вводим размер буфера. 
Сетевой пакет - данные передаются по чуть-чуть. Если какой-то не передался, будет плохо, файл не скачается.
Нужно поиграться с массивами.
___
4 ЛР - Стек
Стек - первый вошёл => последний вышел
Как блинчики на тарелке.
Реализовать в коде самостоятельно - пуш, поп, ограничить стек, удалить эл-т.
Максимум в скользящем окне.
Дан массив, дано окно, надо найти максимальное в окошке, накладываемом на массив.
Повторяем, пока не останется максимальное.
___
Алгоритм шифрования.
