(Писалось не мной)
``` C#
[visibility] тип Имя ([параметры])
			или void
	{операторы; return знач; -1}
```

``` C#
Class Employee { 
public string ToShowName() 
{ return $ “ Сотрудник {Name} с таб. н {Num} “;} //интерполяция 
Вызов метода: 
R1.Text = emp.ToShowName(); 
```

Перегруженная версия метода: 
(Область видимости и тип функции не являются частью сигнатуры при перегрузке, а имя является) 
```C#
using system.drawing ИЛИ using system.drawing2d 

public void ToShowName (PictureBox box) 
{ Graphics g = Graphics.FromHwnd(box.handle); 
// handle инициирует id, FrowHwnd – статический метод для получения контекста графического устройства, привязывания к конкретному объекту (box) 
g.DrawString(this.Name; new Font (“Ariel”, 20), trushes.Red, 10, 20);} 
// параметры надписи (сама надпись, шрифт, кисть, цвет и координаты) 

//Вызов метода: 
emp.ToShowName(p1); 
 
public void ToShowName(Control box) 
//напишем универсальный метод на любой элемент с графической поддержкой  
{box.Text = this.Name}; 
//Вызов метода: 
emp.ToShowName(b1); 
 
//Параметры могут передаваться by value, by refers (по значению, по ссылкке) 
public void ToShowName(TextBox box, bool b) //первый ссылочный, второй по значению 
{box.Text = this.Name 
B = True}; 
```
 
Параметры могут быть преобразованы. Параметры ссылочного типа изменяются (изменяется объект box), а по значению передаётся копия объекта в метод. 
Вызов метода: 
B = False; 
emp.ToShowName(t1, b); 
t2.Text = b.ToString(); // будет написано False, так как другое значение у переменной только внутри метода 
 
in, out, ref // если написать, то передача происходит с изменением 
 
ref – принудительная передача по ссылке 
public void ToShowName(TextBox box, ref bool b)… 
emp.ToShowName(t1, ref b); //при выводе значения будет видно, что за пределами метода значение изменилось  
 
out – выходной параметр, объявленный с ним имеет смысл после выполнения метода 
public string ToShowName(LabelBox box, out string m) 
{ return this.Name; 
m = “Сотрудник записан в БД”;} // при out метод обязан заполнить параметр 
При вызове можем дополнительно выводить параметр 
Вызов метода: 
string m = ““; // при выходном необходимо сначала проиницировать пустой объект, чтобы к нему можно было обратиться 
t2.Text =  emp.ToShowName(l1, out m); //нужно присвоить, т.к. выводиться конкретное значение  
t1.Text = m; (необязательно) 
Чем выходное значение отличается от выходного параметра? – Значение выходного параметра без return, но обязательно присвоенное значение 
 
in – входной параметр (если не писать, то все параметры и так на вход), спецификация – передача параметра по ссылке, но он становится только для чтения, параметры не могут быть изменены в методе, параметры должны быть проиницированы при вызове, но не нужно писать in при вызове 
 
in, out, ref – являются частью сигнатуры, но при одинаковых перегрузка невозможна 
***
Позиционные (именованные) параметры: 
```C#
public void ToShowName(TextBox box, string dep = “Отдел кадров”, sting pos = “Менеджер”) 
{ box.Text = $ "Сотрудник {Name} работает в {dep} в должности {pos}";} //значения pos и dep по умолчанию 
// Вызов метода: 
emp.ToShowName(t1); 
emp.ToShowName(t1, pos: “Секретарь”) // именованная передача, нельзя менять местами именованные параметры, если уже начали с позиционного метода 
emp.ToShowName(t1, pos: “Секретарь”, dep: “Что-то”) // так нельзя писать, изменены позиции у именованных параметров (первый задан позиционно) 
```
Почему нельзя и позиционно и в разнобой оставлять?