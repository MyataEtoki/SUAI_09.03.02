# Свойства класса (билет n)
К полям принято разрабатывать интерфейсы - свойства класса - способ доступа к полям, при этом поля закрывают(private).
Имеет get и set области. Один из них может быть убран. Можно написать программную проверку.(?)

Правила написания:
- Имя поля с строчной буквы.
- Имя свойства такое же, но с заглавной.
```C#
public class Emp {
private string name;
public string Name;
private DateTime birth;

public DateTime Birth {
set {if (value>new DateTime(1/1/2010) && value<DateTime.Now) this.birth=value;}
get { return this.birth.ToUniversalTime();}
}

get {return this.name.Replace(this.name[0].ToString(), this.name[0].ToString().ToUpper());}
set {if (Value.IndexOf('.')= =value.henght-3 && value.hastIndexOf('.')=value.henght-1);}
{this.name=value;}
else {
ShowInfo.ShowMsg("*любое сообщение*");
return;}}
```
К любым статическим объектам обращаемся на уровне класса.
Value - служебная переменная, где временна хранится значение.

Собственный класс.
```C#
public static НазваниеКласса
{public static void 
Show Msg(string s)}
{System.WindowsFroms.messageVox(s);}
```

Класс обезличенный.

Можно для set get писать разную область видимости, по умолчанию public, но поменять можно только одному.
___
## Тестирование.
Если мы создали конструктор пустой, то это не дефолтный, это конструктор без параметров.

```C#
Emp1 = new Emp()
Emp1.Name = T1.text // Сидоров
T2.text = Emp1.Name
```

## DateTime
Это структура.
Вводить руками время, дату незя.
Имеет свойство value - DateTime.Value

Имеет свойства, например Now. 
Она static.(?)
(см. Пример в начале)
# Автоматические свойства класса (билет n+1)

## Пример:
___
public string Должность {get; set;}
___
Есть поле, ненаписанное, private string должность, но оно есть, к нему можно обращаться.
Есть Должность, туда можно что-то записать, что-то прочитать, без проверок.
Зачем оно надо? - *** работа со списком. чтобы привязать коллекции элементов какого-то класса к каким-то элементам.
В коллекции надо указать к какому свойству конкретного элемента оно принадлежит(?)

Привязка.

Нужно чтобы данные были как свойства, а не поля.

Есть класс с 3-мя полями. Просто поля. Мы хотим несколько объектов одного класса - коллекцию. Хотим потом коллекцию привязать к интерфейсу, но чтобы оно разбросанное было.(используем привязку) Имеем список, щёлкаем по сотруднику, а там раскрываются его поля.
Просто работа со списками.
Чтобы значения полей отображались синхронно, по выбору сотрудника, нужно чтобы они не были полями. => привязка.

get; set; - демонстрация, что это автоматически реализуемые свойства.

```C#
dist Emp> Emps = newhist<Emр>();
Emps.Add (new Emp("Сидоров Е.Т."));
// есть ещё AddItems
textBox1.DataBindings.Add("Text", Emps, "Name");
// коллекция с динамикой, которая имеет: Содержание поля, название коллекции, название поля.
// Name - свойство класса.
dateTimePicker1.DataBindings.Add("Value", Emps, "Birth");
ComboBox1.DataBindigs.Add(SelectedValue)
// ListBox1.DataSorts() - загрузит весь список
```

TextValue, SelectedValue, CheckedValue, RadioButtonValue - 4 чего-то.

Назначение - возможность реализации привязки коллекции к интерфейсу (?)

# Индексаторы
Отдельные свойства или поля в классе могут быть описаны как массивы.

Класс персонал - описание штата всех сотрудников.
Свойство, которое массив, можно представить через индексацию.

```C#
class Сотрудник{
public int ТабН{get;}
public string ФИО {get;}
}
public Сотрудник (int n, string name)
{this.ТабН=n, this.ФИО=name;}

class Персонал {
public string NameCompany;
Сотрудник [] persona{get; set;}
public Персонал(Сотрудник[]p)=>this.personal=p;
// разрабатываем индексатор:
public Сотрудник this.[int index]
// this - указываем на конкретный объект, фиксируем индекс
{get => persona[index]; set=>persona[index]=value;}
}

var Штат = new Персонал(new[]{new Сотрудник("Иванов"), new Сотрудник("Сидоров")});
t1Text=Штат[0].ТабН;
t2Text = Штат[0].ФИО;
=> this.personal = p;
```

Можем задать объект с типом сотрудник, потом обращаемся к штат, но к конкретному элементу свойства персона.
Объект класса Персонал - один эл-т массив данных, можно обратиться конкретно к эл-ту массива, через индексацию - `Штат[0] = Сидоров.`
Чтобы обращаться к полю не по его названию, а по индексу - сокращаем запись.
Такое поле в виде массива д.б. заявлено как свойство.

