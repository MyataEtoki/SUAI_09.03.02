```C#
UpCasting 

DownCasting
```

Account (Name, Balance) <= Saving Account (Rate)
*что-то тут рассказала*
Преобразование - представить другим понятием - базовая версия + расширяющая специализация. Содержание станет меньше.
Явное - расширим содержание/Неявное преобразование.

# UpCasting
в начале код с [[5 - Иерархия классов. Наследование.]]
```C#
SavingAccount sa = new SavingAcc("Сидоров", 500);
Account acc = sa; // неявное преобразование
acc.Rate = 0.15; // error
sa.Rate = 0.15; // ok

List<Account>list = new List<Account>(); // типизированный динамический список
list.Add(acc) // Можем добавлять объекты только с типом Account
listBox1.DateScience = list;
listBox1.DisplayMembers = Name;
```
# DownCasting
в начале код с [[5 - Иерархия классов. Наследование.]]
```C#
Account ac = new Account("Петров", 1000);
SavingAcc sa = ac; // error - д.б. явное преобразование
SavingAcc sa = SavingAcc ac; // явное преобразование

SavingAcc sa1 = (SavingAcc) new Account("", sa) // вызываем конструктор класса, который создаст объект с меньшим объёмом, но расширяем его - большее логическое содержание
sa1.Rate = 0.15; // ok
```

# Sealed 
Sealed - модификатор, запрещающий наследование для класса и переопределение для членов класса.
```C#
class Figura {
public Paint[]p;
public virtual void DrawF(PictureBox box) {...}
}
sealed class Triangle: Figura{ // sealed - класс закупорен и не может быть родительским.
public override void DrawF(...) {...}
}
// все вызовы объектов этого класса будут быстрее, короче.
// закупариваем, потому что класс - конечен, дальше не надо наследовать
// точка => (наследование: <-) треугольник - развитие

class Triangle: Figura{
public sealed override void DrawF(...) {...} // метод запечатался
}

```
Закрыть можно не только класс, но и свойства, методы. (но не поля, поля - бессмысленно)

## Повышение производительности с помощью sealed
В открытых классах переопределённые методы вызываются через виртуальную диспетчеризацию. Вызов переопределённых методов в запечатанных классах выполняется непосредственно для текущего класса.

Операции приведение и проверки типов выполняются быстрее в запечатанных классах, не надо сравнивать тип сам с собой. 
=> Отключается виртуальная диспетчеризация, проверки, где такая хуета ещё есть. 

Запечатывается первый уровень наследования. Нулевой уровень запечатывать нет смысла, так как без virtual этот уровень итак не может быть переопределён.
// Что такое первый уровень наследования?

# Модификатор new
Для явного сокрытия членов, унаследованных от базового класса. 
```C#
//продолжение кода выше
class Cone: Trriangle{
// хотим тут DrawF => используем new
public new void DrawF(PictureBos box){...} // оборвали в классе Triangle => тут начали заново
} 
```
# Abstract - Абстрактные классы/члены
Абстрактные члены только в абстрактных классах.
Abstract - идея, чтобы командовать другими
```C#
abstract class Figura {
public Point[]p;
public abstract void DrawF(PictureBox box); // абстрактный класс не имеет реализации, отстутствует тело, то есть нет {}, чисто идея.
// abstract не требует virtual, потому что у нас не выбора.
public abstract string Name {get; set;} // не автоматическое свойство, нерабочее - нельзя наследовать, нельзя использовать - заготовка.
//Автоматическое свойство - то, для которого система сама определяет что и как там.
}
class Rectangle:Figura {
public override void DrawF(PictureBox box){...}
public override string Name{get{...};set{...};}
}
```
1) Производный класс обязан реализовать абстрактные члены базового класса. => мы делаем override
2) Можно отказаться от реализации, но тогда производный класс - тоже становится абстрактным.
3) Создать экземпляры абстрактного класса нельзя.
4) Абстрактный класс содержит описание абстрактных членов (но не только)
5) Абстрактные методы не имеют реализации.
6) Абстрактные свойства не являются автоматическими свойствами.
7) Абстрактный класс может быть в иерархии на любом месте. м.б. он просто копит функциональность
8) (следует из 1 пункта) Abstract приводит к принуждению наследников к переопределению

